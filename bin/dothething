#!/usr/bin/env ruby

require 'optparse'
require 'yaml'
require 'logger'

$path = File.expand_path(File.dirname(__FILE__))
options = {}

#All available options for the adminware command
opt_parser = OptionParser.new do |opt|
 opt.on('-n', '--name NAME', 'The name of the directory') do |v|
  options[:name] = v
 end
 
 opt.on('-h', '--host NAME', 'The name of the host to run the script on') do |v|
  options[:host] = v
 end

 opt.on('-f', '--forward', 'Call the forward script for NAME') do
  options[:command] = 'forward'
 end

 opt.on('-r', '--rewind', 'Call the rewind script for NAME') do 
  options[:command] = 'rewind'
 end
end

#Displays help command on invalid entry
begin opt_parser.parse! ARGV
rescue OptionParser::InvalidOption => e
 puts e
 puts opt_parser
 exit 1
end.parse!

#If no command was entered display help and exit 
if options.empty?
 puts opt_parser
 exit 1
end

module ConfigFile
 class Config
  #Load the config file
  def initialize
   configfile = File.join($path, 'config.yml')
   @config = YAML.load_file(configfile)
  end
  
  #Check if a setting has been set
  def setting_exists?(setting)
   if @config[setting] != nil then
    return true 
   else
    puts "The config file does not contain a path for the setting: #{setting}"
    exit 1 
   end 
  end
  
  #Set the directory for the job   
  def jobdir(name)
   setting_exists?('jobdir')
   @jobdir = @config['jobdir']
   
   #Check if the path given in the file is absolute or relative   
   if @jobdir.include? "../"
    @jobdir = File.join($path, @jobdir, name)
   else
    @jobdir = File.join(@jobdir, name)
   end      
  end
  
  #Check if a file exists
  def file_exist?(setting)
   if File.exist?(@config[setting])
    return true
   else
    #Create the file if it doesn't
    system "touch", "#{@config[setting]}"
    return false
   end
  end
  
  #Check if the log file setting and file exist
  #If they do then it returns the set path
  def logfile
   setting_exists?('logfile')
   file_exist?('logfile')
   @config['logfile']
  end
  
  #Check if the state file setting and file exist
  #If they do then it returns the set path
  def statefile
   setting_exists?('statefile')
   if file_exist?('statefile') == false
    #Create the necessary configuration within state.yaml
    #This only runs if the file was just created within file_exist?
    open(@config['statefile'], 'a') { |f|
     f << "---\n"
     f << "job1:\n"
     f << "  :forward: true\n"
     f << "  :rewind: false\n"
     f << "job2:\n"
     f << "  :forward: true\n"
     f << "  :rewind: false\n" }
   end
   @config['statefile']
  end
 end
  
 #Returns/Creates the config object
 def self.config
  @config ||= Config::new 
 end

 def config
  ConfigFile::config
 end
end

#Logger Module
module EventLogger
 class Log
  include ConfigFile

  #Configure the logger
  def initialize
    @logger = Logger.new(config.logfile)
    @logger.level = Logger::DEBUG
    @logger.formatter = proc do |severity, datetime, progname, msg|
     date_format = datetime.strftime("%d-%m-%Y %H:%M:%S")
     "[#{date_format}]  #{severity.ljust(5)}: #{msg}\n"
    end
    
    #Redirect STDERR messages and append to the log file
    $stderr.reopen(config.logfile, "a")
  end
  
  #This does something
  def method_missing(m,*args,&block)
    log.send(m,*args,&block)
  end
  
  #Return the logger
  def log
   @logger
  end
 end
 
 #Returns/Creates the logger
 def self.log
   @log ||= Log::new
 end

 def log
  EventLogger::log
 end 
end

class Job
 class State
  include EventLogger
  include ConfigFile

  #Toggles value in state hash
  def toggle(name) 
   @sf = YAML.load_file(config.statefile)

   #Finds all true/false values in hash
   t = @sf[name].key(true)
   f = @sf[name].key(false)
 
   #Toggles the values
   @sf[name][:"#{t}"] = false
   @sf[name][:"#{f}"] = true

   File.open(config.statefile, 'w') { |f| YAML.dump(@sf, f) }
  end
 
  #Checks the current state of the requested script for the given job
  def status(name, command)
   @sf = YAML.load_file(config.statefile)
   #The script will run if it's state is currently false
   if @sf[name][:"#{command}"] == false
    toggle(name)
   else
    log.error "Can't execute #{command} for #{name} as it is already set to true"
    exit 1
   end
  end
 end

 include EventLogger
 include ConfigFile
 attr_accessor :command
 attr_accessor :host

 def initialize(name)
   @name = name
   @state = State.new 
 end

 #Performs validation on entered command
 def validate!
  @script = File.join(config.jobdir(@name), @command + '.sh')
  if @host.empty?
   log.info "Attempting to run #{@command} script for #{@name}"
  else 
   log.info "Attempting to run #{@command} script for #{@name} on #{@host}"
   host_exist?
  end
  
  #Check if the directoy and file exist
  if dir_exist? and file_exist? then
   return true
  else
   log.error "Failed to validate"
   exit 1
  end
 end
 
 #Checks if the host exists to run the script on
 def host_exist?
  if system "ssh", @host, "echo", "$$", ">", "/tmp/test"
   @hostexists = true
   return true
  else
   exit 1 
  end
 end
 
 #Checks to see if the directory exists for input NAME
 def dir_exist?
  if Dir.exist?(config.jobdir(@name))
   return true
  else
   log.error "#{config.jobdir(@name)} does not exist"
   return false
  end
 end
 
 #Checks to see if the file exists for input COMMAND
 def file_exist? 
  if File.exist?(@script)
   return true
  else
   log.error "The #{@command} script for #{@name} does not exist"
   return false
  end
 end
 
 #Runs the requested script for the job
 def run
  @state.status(@name, @command)
  if @hostexists == true 
   log.info "Running #{@command} script for #{@name} on #{@host}"
   system "ssh", @host, "bash", @script
  else
   log.info "Running #{@command} script for #{@name}"
   system "bash", @script 
  end
 end
end

name = "#{options[:name]}"
command = "#{options[:command]}"
host = "#{options[:host]}"

#Initialise the job
job = Job.new(name)
job.host = host
job.command = command

#Attempt to validate the command
job.validate!

#Runs the script for the job
job.run
