#!/usr/bin/env ruby

require 'optparse'
require 'yaml'
require 'logger'

$path = File.expand_path(File.dirname(__FILE__))
options = {}

#All available options for the adminware command
opt_parser = OptionParser.new do |opt|
 opt.on('-n', '--name NAME', 'The name of the directory') do |v|
  options[:name] = v
 end
 
 opt.on('-h', '--host NAME', 'The name of the host to run the script on') do |v|
  options[:host] = v
 end

 opt.on('-f', '--forward', 'Call the forward script for NAME') do
  options[:command] = 'forward'
 end

 opt.on('-r', '--rewind', 'Call the rewind script for NAME') do 
  options[:command] = 'rewind'
 end
end

#Displays help command on invalid entry
begin opt_parser.parse! ARGV
rescue OptionParser::InvalidOption => e
 puts e
 puts opt_parser
 exit 1
end.parse!

#If no command was entered display help and exit 
if options.empty?
 puts opt_parser
 exit 1
end

module ConfigFile
 class Config
  
  DEFAULT_JOBDIR = "jobs/"
  DEFAULT_LOGFILE = "logs/adminware.log"
  DEFAULT_STATEFILE = "var/state.yaml"

  #Load the config file
  def initialize
   configfile = File.join($path, 'config.yml')
   @config = YAML.load_file(configfile)

   @jobdir = @config['jobdir'] ||= DEFAULT_JOBDIR
   @jobdir = set_path(@jobdir)

   @logfile = @config['logfile'] ||= DEFAULT_LOGFILE
   @logfile = set_path(@logfile)

   @statefile = @config['statefile'] ||= DEFAULT_STATEFILE
   @statefile = set_path(@statefile)
  end
  
  private 

  #Sets the path for the given config setting 
  def set_path(path)
   #path = @config[setting]
      
   #Checks if the path is absolute or relative
   if File.exist?(path) == false
    #Relative
    path = File.join($path,"..", path)
   else
    #Absolute
    path
   end
  end  
 
  #Check if a file exists
  def file_exist?(file)
   if File.exist?(file)
    return true
   else
    #Create the file if it doesn't
    system "touch", "#{file}"
   end
  end
  
  public 
 
  def jobdir
   @jobdir
  end

  def logfile
   file_exist?(@logfile)
   @logfile
  end
  
  def statefile
   file_exist?(@statefile)
   @statefile
  end
 end
  
 #Returns/Creates the config object
 def self.config
  @config ||= Config::new 
 end

 def config
  ConfigFile::config
 end
end

#Logger Module
module EventLogger
 class Log
  include ConfigFile

  #Configure the logger
  def initialize
    @logger = Logger.new(config.logfile)
    @logger.level = Logger::DEBUG
    @logger.formatter = proc do |severity, datetime, progname, msg|
     date_format = datetime.strftime("%d-%m-%Y %H:%M:%S")
     "[#{date_format}]  #{severity.ljust(5)}: #{msg}\n"
    end
    
    #Redirect STDERR messages and append to the log file
    $stderr.reopen(config.logfile, "a")
  end
  
  #This does something
  def method_missing(m,*args,&block)
    log.send(m,*args,&block)
  end
  
  #Return the logger
  def log
   @logger
  end
 end
 
 #Returns/Creates the logger
 def self.log
   @log ||= Log::new
 end

 def log
  EventLogger::log
 end 
end

class Job
 class State
  include EventLogger
  include ConfigFile
  
  def initialize(name)
   @name = name 
   @file = YAML.load_file(config.statefile) || {}
  end
  
  #Checks if the file contains the key for the job 
  def check_file
   #If the job has no key it creates the necessary structure for it
   if !(system "grep", "#{@name}", "#{config.statefile}", "-q")
     test = {"#{@name}"=> {:forward=>false, :rewind=>true}}
     File.open(config.statefile, 'w') { |f| YAML.dump(@file.merge(test), f)}
     @file = YAML.load_file(config.statefile)
   end
  end

  #Checks the current state of the given job
  def status
   #Returns the current key with a value of true
   @file["#{@name}"].key(true)
  end
  
  #Toggles forward to true
  def forward
   @file[@name][:forward] = true
   @file[@name][:rewind] = false

   File.open(config.statefile, 'w') { |f| YAML.dump(@file, f) }
  end

  #Toggles rewind to true
  def rewind
   @file[@name][:forward] = false
   @file[@name][:rewind] = true

   File.open(config.statefile, 'w') { |f| YAML.dump(@file, f) }
  end
 end

 include EventLogger
 include ConfigFile
 attr_accessor :command
 attr_accessor :host

 def initialize(name)
   @name = name
   @state = State.new(name) 
 end

 #Performs validation on entered command
 def validate!
  @script = File.join(config.jobdir, @name, @command + '.sh')
  if @host.empty?
   log.info "Attempting to run #{@command} script for #{@name}"
  else 
   log.info "Attempting to run #{@command} script for #{@name} on #{@host}"
  end
  
  #Check if the directoy and file exist
  if dir_exist? and file_exist? then
   @state.check_file
   return true
  else
   log.error "Failed to validate"
   exit 1
  end
 end
 
 #Checks to see if the directory exists for input NAME
 def dir_exist?
  if Dir.exist?(config.jobdir)
   return true
  else
   log.error "#{config.jobdir} does not exist"
   return false
  end
 end
 
 #Checks to see if the file exists for input COMMAND:
 def file_exist? 
  if File.exist?(@script)
   return true
  else
   log.error "The #{@command} script for #{@name} does not exist"
   return false
  end
 end
 
 #Runs the requested script for the job
 def run
  #If the current command's state is false the job can run
  if "#{@state.status}" != @command
   if !@host.empty?
    log.info "Running #{@command} script for #{@name} on #{@host}"
    system "ssh", @host, "bash", @script
   else
    log.info "Running #{@command} script for #{@name}"
    system "bash", @script 
   end
   if @command == 'forward' then @state.forward else @state.rewind end
  else
   log.error "Can't execute #{@command} script for #{@name} as it is already set to true"
   exit 1
  end
 end
end

name = "#{options[:name]}"
command = "#{options[:command]}"
host = "#{options[:host]}"

#Initialise the job
job = Job.new(name)
job.host = host
job.command = command

#Attempt to validate the command
job.validate!

#Runs the script for the job
job.run
